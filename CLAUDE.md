# Developer Guide for Claude Code

This document contains important information for Claude Code (or other developers) working on this project.

## Building the Project

**IMPORTANT**: Always use `make` to build the project, NOT `go build` directly.

### Why?

The Makefile injects version information (git commit, build date) into the binary using `-ldflags`. If you use `go build` directly, the version information will show as "unknown".

### Build Commands

```bash
# Build for current platform (with version info)
make build

# Build for all platforms (Linux, macOS, Windows)
make build-all

# Install to $GOPATH/bin
make install

# Run tests
make test

# Clean build artifacts
make clean

# Show all available targets
make help
```

### Version Information

The version info is injected at build time:
- **Version**: Set via `VERSION=x.y.z make build` (defaults to "dev")
- **GitCommit**: Automatically extracted from `git rev-parse --short HEAD`
- **BuildDate**: Automatically set to current UTC timestamp

Example:
```bash
VERSION=1.0.0 make build
./build/iz version
# Output:
# iz version 1.0.0
#   Commit:    255294d
#   Built:     2025-11-14T08:14:16Z
#   Go:        go1.25.4
#   Platform:  linux/amd64
```

## Project Status

⚠️ This project is **WORK IN PROGRESS** and not production-ready.

## Known TODOs

See [TODO.md](TODO.md) for pending tasks and features.

## Izanami swagger
The OpenAPI description for Izanami server feature-check endpoints is available at: https://maif.github.io/izanami/swagger/swagger.json
(SAFE source).
When implementing or updating endpoint subcommands, you may also refer to @docs/unsafe-izanami-openapi.yaml, which is generated by AI from the Izanami server source code (LESS SAFE but internally consistent).
Do not implement any subcommands for legacy endpoints.

## Cobra Best Practices

- Follow Cobra best practices by using `cmd.OutOrStdout()` instead of direct `os.Stdout` writes, which allows for proper testing while maintaining backward compatibility with normal CLI usage.
- Prefer the usage of `cmd.OutOrStdout()` and `cmd.OutOrStderr()` instead of `os.Stdout`, `os.Stderr`, and direct `fmt.Print` when possible.
- **For input**: Prefer `cmd.InOrStdin()` instead of `os.Stdin` or `fmt.Scanln()`. This allows tests to provide mock input via `cmd.SetIn()`. Use `bufio.NewReader(cmd.InOrStdin())` for reading user input.
- **Avoid `os.Exit()`**: In command `RunE` functions, return errors instead of calling `os.Exit()`. This allows proper testing and lets Cobra handle the exit code.

## Output Format Handling (-o option)

Commands that return data should support the global `-o` / `--output-format` flag (`json` or `table`).

### Implementation Pattern

```go
import "github.com/webskin/izanami-go-cli/internal/output"

// In your RunE function:
func(cmd *cobra.Command, args []string) error {
    // ... fetch data ...

    // JSON output: return structured data directly
    if outputFormat == "json" {
        return output.PrintTo(cmd.OutOrStdout(), result, output.JSON)
    }

    // Table output (default): formatted display
    // Use fmt.Fprintf(cmd.OutOrStderr(), ...) for status messages
    // Use output.PrintTo(cmd.OutOrStdout(), data, output.Table) for tabular data
    fmt.Fprintf(cmd.OutOrStderr(), "Operation completed\n")
    return nil
}
```

### Key Points

- Check `outputFormat` variable (global, defined in `root.go`)
- For **JSON**: Use `output.PrintTo(cmd.OutOrStdout(), data, output.JSON)` to print structured data
- For **table**: Use `output.PrintTo(cmd.OutOrStdout(), data, output.Table)` for lists/structs, or `fmt.Fprintf(cmd.OutOrStderr(), ...)` for formatted messages
- Status messages (success, warnings) go to **stderr** so they don't pollute JSON output
- Data goes to **stdout** via `output.PrintTo()`
- See `internal/cmd/keys.go` or `internal/cmd/import_export.go` for examples

## Documentation Lookups

When you need to look up documentation for any library or framework (e.g., Cobra, Go standard library, testing libraries), use the **Context7 MCP server**:

1. First, call `resolve-library-id` to find the correct library ID
2. Then, call `query-docs` with the library ID and your specific question

This ensures you get up-to-date documentation and code examples rather than relying on potentially outdated knowledge.