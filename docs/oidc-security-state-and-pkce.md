# OIDC Security: State and PKCE (Code Verifier)

This document explains why the `state` parameter and PKCE (Proof Key for Code Exchange)
are critical for securing OIDC authentication flows.

## The State Parameter

### What is State?

The `state` parameter is a random, unguessable value generated by the client (CLI)
before starting the OIDC flow. It's sent to the authorization server and returned
unchanged in the callback.

### Attack Without State: CSRF (Cross-Site Request Forgery)

Without state validation, an attacker can trick a victim into logging into
the attacker's account:

```
┌──────────┐         ┌──────────┐         ┌─────────────┐         ┌──────────────┐
│ Attacker │         │  Victim  │         │   Izanami   │         │ OIDC Provider│
└────┬─────┘         └────┬─────┘         └──────┬──────┘         └──────┬───────┘
     │                    │                      │                       │
     │ 1. Attacker starts OIDC login             │                       │
     │ ─────────────────────────────────────────>│                       │
     │                                           │                       │
     │ 2. Attacker authenticates as themselves   │                       │
     │ ─────────────────────────────────────────────────────────────────>│
     │                                           │                       │
     │ 3. Get callback URL with authorization code                       │
     │ <─────────────────────────────────────────────────────────────────│
     │    /callback?code=AUTH_CODE_FOR_ATTACKER                          │
     │                                           │                       │
     │ 4. Attacker sends this URL to victim      │                       │
     │    (email, chat, malicious website)       │                       │
     │ ──────────────────>│                      │                       │
     │                    │                      │                       │
     │                    │ 5. Victim clicks link (or auto-redirect)     │
     │                    │ ────────────────────>│                       │
     │                    │    /callback?code=AUTH_CODE_FOR_ATTACKER     │
     │                    │                      │                       │
     │                    │                      │ 6. Server exchanges code
     │                    │                      │    Gets ATTACKER's token!
     │                    │                      │                       │
     │                    │ 7. Victim is now logged in as ATTACKER       │
     │                    │ <────────────────────│                       │
     │                    │                      │                       │
     ▼                    ▼                      ▼                       ▼

     RESULT: Victim performs actions thinking they're in their own account,
             but they're actually in the attacker's account!

     IMPACT: - Victim uploads sensitive files to attacker's account
             - Victim enters credit card info in attacker's account
             - Attacker sees everything victim does
```

### How State Prevents This Attack

```
┌──────────┐         ┌──────────┐         ┌─────────────┐         ┌──────────────┐
│ Attacker │         │  Victim  │         │   Izanami   │         │ OIDC Provider│
└────┬─────┘         └────┬─────┘         └──────┬──────┘         └──────┬───────┘
     │                    │                      │                       │
     │ 1. Attacker generates state=ABC123        │                       │
     │ ─────────────────────────────────────────>│                       │
     │                                           │──┐                    │
     │                                           │  │ Store: ABC123      │
     │                                           │<─┘ belongs to Attacker│
     │                                           │                       │
     │ 2. Attacker authenticates                 │                       │
     │ ─────────────────────────────────────────────────────────────────>│
     │                                           │                       │
     │ 3. Get callback with code + state         │                       │
     │ <─────────────────────────────────────────────────────────────────│
     │    /callback?code=AUTH_CODE&state=ABC123                          │
     │                                           │                       │
     │ 4. Attacker sends URL to victim           │                       │
     │ ──────────────────>│                      │                       │
     │                    │                      │                       │
     │                    │ 5. Victim's CLI has its own state=XYZ789     │
     │                    │    Victim clicks attacker's link             │
     │                    │ ────────────────────>│                       │
     │                    │    /callback?code=AUTH_CODE&state=ABC123     │
     │                    │                      │                       │
     │                    │                      │──┐                    │
     │                    │                      │  │ Check: Is ABC123   │
     │                    │                      │  │ valid for Victim?  │
     │                    │                      │<─┘ NO! Reject!        │
     │                    │                      │                       │
     │                    │ 6. ERROR: Invalid state                      │
     │                    │ <────────────────────│                       │
     │                    │                      │                       │
     ▼                    ▼                      ▼                       ▼

     RESULT: Attack blocked! The state parameter didn't match.
```

### CLI State Implementation

In the Izanami CLI, the state is:
- 32 bytes (256 bits) of cryptographically secure random data
- Base64url encoded (43 characters)
- Prefixed with `cli:` to distinguish CLI flows from browser flows
- Stored server-side with a 5-minute TTL

```
Example state: cli:hFFFhvJpDPc8_TAsc_Aex_E9d-Mjv53-QzSQFiGRyR0
                │   └─────────────────────────────────────────────┘
                │                    43 chars base64url
                └── CLI flow marker
```

---

## PKCE (Proof Key for Code Exchange)

### What is PKCE?

PKCE adds a layer of protection using a code verifier and code challenge:

1. **Code Verifier**: A random secret generated by the client
2. **Code Challenge**: A hash of the verifier (SHA256, base64url encoded)

The challenge is sent with the authorization request, but the verifier is only
sent when exchanging the code for tokens.

### Attack Without PKCE: Authorization Code Interception

Without PKCE, an attacker who intercepts the authorization code can exchange
it for tokens:

```
┌─────────┐         ┌──────────┐         ┌─────────────┐         ┌──────────────┐
│   CLI   │         │ Attacker │         │   Izanami   │         │ OIDC Provider│
└────┬────┘         └────┬─────┘         └──────┬──────┘         └──────┬───────┘
     │                   │                      │                       │
     │ 1. CLI initiates OIDC login              │                       │
     │ ────────────────────────────────────────>│                       │
     │                                          │                       │
     │ 2. User authenticates in browser         │                       │
     │ ─────────────────────────────────────────────────────────────────>
     │                                          │                       │
     │ 3. Callback with authorization code      │                       │
     │ <────────────────────────────────────────────────────────────────│
     │    /callback?code=SECRET_AUTH_CODE       │                       │
     │                   │                      │                       │
     │                   │ 4. Attacker intercepts the code              │
     │                   │    (network sniffing, malware, logs, etc.)   │
     │                   │ <────────────────────│                       │
     │                   │    code=SECRET_AUTH_CODE                     │
     │                   │                      │                       │
     │                   │ 5. Attacker exchanges code for token         │
     │                   │ ─────────────────────────────────────────────>
     │                   │    POST /token                               │
     │                   │    code=SECRET_AUTH_CODE                     │
     │                   │    client_id=...                             │
     │                   │                      │                       │
     │                   │ 6. Attacker gets victim's token!             │
     │                   │ <─────────────────────────────────────────────
     │                   │    { "access_token": "...", ... }            │
     │                   │                      │                       │
     ▼                   ▼                      ▼                       ▼

     RESULT: Attacker has valid tokens for the victim's account!

     HOW CODE CAN BE INTERCEPTED:
     - Malicious browser extension
     - Compromised redirect URI handler
     - Network packet sniffing (if not HTTPS)
     - Server logs exposure
     - Referer header leakage
```

### How PKCE Prevents This Attack

```
┌─────────┐         ┌──────────┐         ┌─────────────┐         ┌──────────────┐
│   CLI   │         │ Attacker │         │   Izanami   │         │ OIDC Provider│
└────┬────┘         └────┬─────┘         └──────┬──────┘         └──────┬───────┘
     │                   │                      │                       │
     │ 1. CLI generates:                        │                       │
     │    verifier = "random_secret_abc123..."  │                       │
     │    challenge = SHA256(verifier)          │                       │
     │                   │                      │                       │
     │ 2. CLI sends challenge (NOT verifier)    │                       │
     │ ────────────────────────────────────────>│                       │
     │    code_challenge=...&code_challenge_method=S256                 │
     │                   │                      │──┐                    │
     │                   │                      │  │ Store challenge    │
     │                   │                      │<─┘                    │
     │                   │                      │                       │
     │ 3. User authenticates                    │                       │
     │ ─────────────────────────────────────────────────────────────────>
     │                   │                      │                       │
     │ 4. Callback with code                    │                       │
     │ <────────────────────────────────────────────────────────────────│
     │                   │                      │                       │
     │                   │ 5. Attacker intercepts code                  │
     │                   │ <────────────────────│                       │
     │                   │                      │                       │
     │                   │ 6. Attacker tries to exchange code           │
     │                   │ ─────────────────────────────────────────────>
     │                   │    POST /token                               │
     │                   │    code=...                                  │
     │                   │    code_verifier=??? (attacker doesn't know!)│
     │                   │                      │                       │
     │                   │                      │──┐ SHA256(???) !=     │
     │                   │                      │  │ stored challenge   │
     │                   │                      │<─┘                    │
     │                   │                      │                       │
     │                   │ 7. REJECTED! Invalid code_verifier           │
     │                   │ <─────────────────────────────────────────────
     │                   │    { "error": "invalid_grant" }              │
     │                   │                      │                       │
     │ 8. CLI exchanges code with correct verifier                      │
     │ ─────────────────────────────────────────────────────────────────>
     │    code=...&code_verifier=random_secret_abc123...                │
     │                   │                      │                       │
     │                   │                      │──┐ SHA256(verifier)   │
     │                   │                      │  │ == challenge ✓     │
     │                   │                      │<─┘                    │
     │                   │                      │                       │
     │ 9. CLI gets tokens                       │                       │
     │ <─────────────────────────────────────────────────────────────────
     │    { "access_token": "...", ... }        │                       │
     │                   │                      │                       │
     ▼                   ▼                      ▼                       ▼

     RESULT: Attack blocked! Attacker can't use the code without the verifier.
```

### PKCE Flow Summary

```
    CLIENT                                          SERVER
    ══════                                          ══════

    ┌─────────────────────┐
    │ Generate:           │
    │ verifier = random() │
    │ challenge = SHA256  │
    │             (verifier)│
    └──────────┬──────────┘
               │
               │  Authorization Request
               │  + code_challenge
               │  + code_challenge_method=S256
               ▼
          ─────────────────────────────────────>  ┌─────────────────────┐
                                                  │ Store challenge     │
                                                  │ with auth session   │
                                                  └─────────────────────┘

               │  Authorization Code
               │  (after user authenticates)
          <─────────────────────────────────────
               │
               │  Token Request
               │  + code
               │  + code_verifier  ◄── The actual secret!
               ▼
          ─────────────────────────────────────>  ┌─────────────────────┐
                                                  │ Verify:             │
                                                  │ SHA256(verifier)    │
                                                  │   == challenge?     │
                                                  └─────────────────────┘

               │  Access Token
               │  (only if verifier matches)
          <─────────────────────────────────────
```

---

## Combined Protection: State + PKCE

When used together, state and PKCE protect against different attack vectors:

| Protection | Prevents | How |
|------------|----------|-----|
| **State** | CSRF attacks | Ensures the callback belongs to the session that initiated the request |
| **PKCE** | Code interception | Ensures only the original client can exchange the code |

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        OIDC Security Layers                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                         STATE PARAMETER                             │   │
│   │                                                                     │   │
│   │   Protects: Session integrity                                       │   │
│   │   Prevents: CSRF, session fixation                                  │   │
│   │   Binding:  Links callback to the user who initiated auth           │   │
│   │                                                                     │   │
│   │   ┌─────────────────────────────────────────────────────────────┐   │   │
│   │   │                    PKCE (Code Verifier)                     │   │   │
│   │   │                                                             │   │   │
│   │   │   Protects: Authorization code                              │   │   │
│   │   │   Prevents: Code interception/theft                         │   │   │
│   │   │   Binding:  Links code exchange to the original request     │   │   │
│   │   │                                                             │   │   │
│   │   │   ┌─────────────────────────────────────────────────────┐   │   │   │
│   │   │   │                  YOUR TOKEN                         │   │   │   │
│   │   │   │                                                     │   │   │   │
│   │   │   │   Protected by both state AND PKCE                  │   │   │   │
│   │   │   │                                                     │   │   │   │
│   │   │   └─────────────────────────────────────────────────────┘   │   │   │
│   │   │                                                             │   │   │
│   │   └─────────────────────────────────────────────────────────────┘   │   │
│   │                                                                     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Implementation in Izanami CLI

The Izanami CLI implements both protections:

### State Generation (CLI side)
```go
// 32 bytes = 256 bits of entropy
state := base64url(crypto/rand(32))
// Result: "hFFFhvJpDPc8_TAsc_Aex_E9d-Mjv53-QzSQFiGRyR0"
```

### PKCE (Server side)
The Izanami server generates and manages PKCE when communicating with the OIDC provider:
```go
// Server generates verifier when CLI initiates login
codeVerifier := base64url(crypto/rand(32))
codeChallenge := base64url(sha256(codeVerifier))

// Server stores verifier, sends challenge to OIDC provider
// Server uses verifier when exchanging code for token
```

### Why PKCE is Server-Side in CLI Flow

In a traditional browser OIDC flow, the client (browser app) handles PKCE.
In the CLI flow, the server handles PKCE because:

1. The CLI doesn't directly communicate with the OIDC provider
2. The server acts as an intermediary between CLI and OIDC provider
3. The state parameter already binds the CLI to its session
4. PKCE protects the server-to-OIDC-provider communication

```
┌───────┐              ┌─────────────┐              ┌──────────────┐
│  CLI  │◄── state ───►│   Izanami   │◄── PKCE ───►│ OIDC Provider│
└───────┘              └─────────────┘              └──────────────┘
                              │
                              ▼
                       Server manages PKCE
                       to protect its own
                       token exchange with
                       OIDC provider
```

---

## References

- [RFC 6749 - OAuth 2.0](https://tools.ietf.org/html/rfc6749) - Section 10.12 (CSRF)
- [RFC 7636 - PKCE](https://tools.ietf.org/html/rfc7636) - Proof Key for Code Exchange
- [OAuth 2.0 Security Best Practices](https://tools.ietf.org/html/draft-ietf-oauth-security-topics)
