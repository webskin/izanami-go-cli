package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// Default polling configuration values.
// These can be overridden when creating a new TokenPoller.
const (
	// DefaultPollInterval is the time between successive poll requests.
	// 2 seconds balances responsiveness with server load.
	DefaultPollInterval = 2 * time.Second

	// DefaultTimeout is the maximum time to wait for authentication.
	// 5 minutes allows plenty of time for OIDC login, including MFA.
	DefaultTimeout = 5 * time.Minute

	// DefaultHTTPTimeout is the timeout for individual HTTP requests.
	// 10 seconds is enough for a simple GET request even on slow connections.
	DefaultHTTPTimeout = 10 * time.Second
)

// TokenPoller handles polling the Izanami server for completed OIDC authentication.
//
// # Polling Mechanism
//
// The poller repeatedly calls the /api/admin/cli-token endpoint until one of:
//   - Token is ready (200 OK) - returns the token
//   - Authentication pending (202 Accepted) - continues polling
//   - Invalid state (404 Not Found) - returns error
//   - Token expired (410 Gone) - returns error
//   - Rate limited (429 Too Many Requests) - waits and continues
//   - Timeout reached - returns error
//
// # Rate Limiting
//
// The server enforces rate limiting (60 polls/minute per state).
// When rate limited (429), the poller respects the retryAfter value
// and adjusts the polling interval accordingly.
//
// # Thread Safety
//
// TokenPoller is NOT safe for concurrent use. Create a new poller for
// each authentication attempt.
type TokenPoller struct {
	// client is the HTTP client used for polling requests.
	// It has its own timeout for individual requests.
	client *http.Client

	// baseURL is the Izanami server URL (e.g., "https://izanami.example.com")
	baseURL string

	// state is the cryptographic state parameter generated by GenerateState()
	state string

	// pollInterval is the time between poll requests (default: 2s)
	pollInterval time.Duration
}

// PollResult represents the result of a single poll request.
type PollResult struct {
	// Token is the JWT token returned on successful authentication.
	// Only populated when Ready is true.
	Token string

	// Ready indicates whether the authentication is complete.
	// When true, Token contains the valid JWT.
	Ready bool

	// RetryAfter is the number of seconds to wait before the next poll.
	// Only populated on rate limiting (429). Zero means use normal interval.
	RetryAfter int
}

// tokenResponse is the JSON structure returned by the cli-token endpoint on success.
type tokenResponse struct {
	Token string `json:"token"`
}

// pendingResponse is the JSON structure returned when authentication is pending.
type pendingResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

// errorResponse is the JSON structure returned on errors.
type errorResponse struct {
	Message    string `json:"message"`
	RetryAfter int    `json:"retryAfter,omitempty"`
}

// NewTokenPoller creates a new TokenPoller for polling authentication status.
//
// Parameters:
//   - baseURL: The Izanami server URL (e.g., "https://izanami.example.com").
//     Trailing slashes are automatically removed.
//   - state: The state parameter from GenerateState(). Must be exactly 43 characters.
//   - interval: Time between poll requests. Use 0 for DefaultPollInterval (2s).
//
// Example:
//
//	state, _ := auth.GenerateState()
//	poller := auth.NewTokenPoller("https://izanami.example.com", state, 0)
//	token, err := poller.WaitForToken(ctx, 5*time.Minute)
func NewTokenPoller(baseURL, state string, interval time.Duration) *TokenPoller {
	if interval <= 0 {
		interval = DefaultPollInterval
	}

	return &TokenPoller{
		client: &http.Client{
			Timeout: DefaultHTTPTimeout,
			// Don't follow redirects - we expect JSON responses
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		},
		baseURL:      strings.TrimSuffix(baseURL, "/"),
		state:        state,
		pollInterval: interval,
	}
}

// Poll makes a single request to check if the token is ready.
//
// This method performs one HTTP request to /api/admin/cli-token?state={state}
// and interprets the response.
//
// # Response Handling
//
// The method handles the following HTTP status codes:
//
//   - 200 OK: Token ready. Returns PollResult{Ready: true, Token: "..."}
//
//   - 202 Accepted: Authentication pending. Returns PollResult{Ready: false}
//
//   - 404 Not Found: Invalid or unknown state. Returns error.
//     This typically means the state was never registered or has already been used.
//
//   - 410 Gone: Token expired before pickup. Returns error.
//     The user completed authentication but the CLI didn't poll in time.
//
//   - 429 Too Many Requests: Rate limited. Returns PollResult{RetryAfter: N}.
//     The caller should wait N seconds before the next poll.
//
//   - Other status codes: Returns error with status code and response body.
//
// # Error Handling
//
// Returns an error for permanent failures (404, 410, network errors).
// For transient failures (429), returns a PollResult with RetryAfter set.
// The caller should only retry on PollResult with Ready=false and no error.
func (p *TokenPoller) Poll(ctx context.Context) (*PollResult, error) {
	// Build the polling URL
	url := fmt.Sprintf("%s/api/admin/cli-token?state=%s", p.baseURL, p.state)

	// Create request with context for cancellation support
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers to indicate we expect JSON
	req.Header.Set("Accept", "application/json")

	// Execute the request
	resp, err := p.client.Do(req)
	if err != nil {
		// Check if context was cancelled
		if ctx.Err() != nil {
			return nil, ctx.Err()
		}
		return nil, fmt.Errorf("failed to poll token endpoint: %w", err)
	}
	defer resp.Body.Close()

	// Handle response based on status code
	switch resp.StatusCode {
	case http.StatusOK:
		// Token ready - parse and return
		var result tokenResponse
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, fmt.Errorf("failed to decode token response: %w", err)
		}
		if result.Token == "" {
			return nil, fmt.Errorf("server returned empty token")
		}
		return &PollResult{Token: result.Token, Ready: true}, nil

	case http.StatusAccepted:
		// Authentication still pending - continue polling
		return &PollResult{Ready: false}, nil

	case http.StatusNotFound:
		// Invalid or unknown state
		// This is a permanent error - the state was never registered or already used
		return nil, fmt.Errorf("invalid or unknown state: the authentication session may have expired or been completed already")

	case http.StatusGone:
		// Token expired before pickup
		// The user completed auth but CLI didn't poll in time (within 2 min)
		return nil, fmt.Errorf("authentication expired: the token was generated but not retrieved in time. Please try again")

	case http.StatusTooManyRequests:
		// Rate limited - parse retryAfter and continue
		var errResp errorResponse
		if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
			// If we can't parse the response, use a default retry value
			return &PollResult{Ready: false, RetryAfter: 5}, nil
		}
		if errResp.RetryAfter <= 0 {
			errResp.RetryAfter = 5 // Default to 5 seconds if not specified
		}
		return &PollResult{Ready: false, RetryAfter: errResp.RetryAfter}, nil

	case http.StatusBadRequest:
		// Invalid state format
		var errResp errorResponse
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("invalid state format: %s", errResp.Message)

	default:
		// Unexpected status code - read body for error message
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response from server (status %d): %s", resp.StatusCode, string(body))
	}
}

// WaitForToken polls until the token is ready or timeout/error occurs.
//
// This is the main entry point for waiting on authentication completion.
// It handles the polling loop, including rate limiting and timeout.
//
// # Polling Loop
//
// The method polls at regular intervals (default: 2 seconds) until:
//   - Token is received (returns token)
//   - Context is cancelled or times out (returns error)
//   - Permanent error occurs (returns error)
//
// # Rate Limiting
//
// When the server responds with 429 Too Many Requests, the poller
// respects the retryAfter value and adjusts the polling interval.
//
// # Cancellation
//
// The polling can be cancelled by cancelling the provided context.
// This allows the caller to implement their own timeout or user cancellation.
//
// Parameters:
//   - ctx: Context for cancellation. The method creates a child context with timeout.
//   - timeout: Maximum time to wait for authentication. Use 0 for DefaultTimeout (5m).
//
// Returns:
//   - token: The JWT token on success
//   - error: On timeout, cancellation, or permanent failure
//
// Example:
//
//	poller := auth.NewTokenPoller(baseURL, state, 0)
//	token, err := poller.WaitForToken(context.Background(), 5*time.Minute)
//	if err != nil {
//	    // Handle error (timeout, invalid state, etc.)
//	}
//	// Use token for API requests
func (p *TokenPoller) WaitForToken(ctx context.Context, timeout time.Duration) (string, error) {
	if timeout <= 0 {
		timeout = DefaultTimeout
	}

	// Create a context with timeout
	// This ensures we don't poll forever even if individual requests succeed
	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	// Create ticker for regular polling
	// The ticker is reset when rate limited to respect server's retryAfter
	ticker := time.NewTicker(p.pollInterval)
	defer ticker.Stop()

	// Poll immediately on first call, then wait for ticker
	firstPoll := true

	for {
		// Wait for next poll interval (except on first iteration)
		if !firstPoll {
			select {
			case <-ctx.Done():
				// Context cancelled or timed out
				if ctx.Err() == context.DeadlineExceeded {
					return "", fmt.Errorf("authentication timed out after %v", timeout)
				}
				return "", ctx.Err()
			case <-ticker.C:
				// Time for next poll
			}
		}
		firstPoll = false

		// Make a poll request
		result, err := p.Poll(ctx)
		if err != nil {
			// Permanent error (404, 410, network error) - abort polling
			return "", err
		}

		if result.Ready {
			// Token received - authentication successful!
			return result.Token, nil
		}

		if result.RetryAfter > 0 {
			// Rate limited - adjust polling interval
			// Reset ticker to respect server's requested wait time
			ticker.Reset(time.Duration(result.RetryAfter) * time.Second)
		}

		// 202 Accepted - continue polling at normal interval
	}
}

// CheckServerSupport checks if the server supports CLI OIDC authentication.
//
// This method makes a lightweight request to the cli-login endpoint to verify
// the server has the required endpoints for automatic token polling.
//
// # How It Works
//
// The method sends a HEAD request to /api/admin/cli-login. If the server
// responds with anything other than 404, it's assumed to support CLI auth.
//
// Note: This uses a fake state parameter since we're only checking if the
// endpoint exists, not actually starting authentication.
//
// Parameters:
//   - ctx: Context for cancellation
//   - baseURL: The Izanami server URL
//
// Returns:
//   - true if the server supports CLI OIDC authentication
//   - false if the endpoint doesn't exist (404) or on error
func CheckServerSupport(ctx context.Context, baseURL string) bool {
	baseURL = strings.TrimSuffix(baseURL, "/")

	// Use a dummy state just to check if the endpoint exists
	// We're making a GET request but will check the response status
	url := fmt.Sprintf("%s/api/admin/cli-login?state=check", baseURL)

	client := &http.Client{
		Timeout: 5 * time.Second,
		// Don't follow redirects - a redirect means the endpoint exists
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return false
	}

	resp, err := client.Do(req)
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	// If we get a redirect (302) or bad request (400 for invalid state),
	// the endpoint exists. Only 404 means it doesn't exist.
	// Note: 400 is expected because "check" is not a valid state format.
	return resp.StatusCode != http.StatusNotFound
}
