// Package auth provides authentication utilities for CLI OIDC flows.
//
// # State-Based Token Polling Flow
//
// This package implements the CLI side of OIDC authentication using
// state-based token polling. This approach allows CLI tools to authenticate
// users via browser-based OIDC without requiring a local HTTP callback server.
//
// ## How It Works
//
// The flow works as follows:
//
//  1. CLI generates a cryptographically secure state (32 bytes, base64url)
//  2. CLI opens browser to /api/admin/cli-login?state={state}
//  3. Server stores pending auth, redirects to OIDC provider with state prefixed as cli:{state}
//  4. User authenticates in browser with the OIDC provider
//  5. Server detects CLI flow from cli: prefix in callback, stores token for pickup
//  6. CLI polls /api/admin/cli-token?state={state} every 2 seconds until token received
//  7. CLI saves token to session file (~/.izsessions)
//
// ## Why State-Based Polling?
//
// Traditional CLI OIDC flows use a local callback server, but this requires:
//   - OIDC provider to support localhost redirect URIs (not always possible)
//   - Random port allocation and firewall/NAT traversal
//
// State-based polling avoids these issues:
//   - Works with ANY OIDC provider (no configuration changes needed)
//   - CLI only makes outbound requests (no local server needed)
//   - State parameter is a standard OAuth 2.0 mechanism
//
// ## Security Features
//
//   - 256-bit state entropy prevents guessing (cryptographically secure random)
//   - Single-use tokens (deleted from server after retrieval)
//   - Rate limiting (60 polls/minute per state)
//   - Short TTLs (5 min pending auth, 2 min token pickup window)
//   - PKCE support inherited from server OIDC flow
//
// ## Server Endpoints Used
//
//   - GET /api/admin/cli-login?state={state}  - Initiate OIDC flow
//   - GET /api/admin/cli-token?state={state}  - Poll for completed token
//
// See features/feat-0003-oidc-login.md for full specification.
package auth

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
)

// StateLength is the number of random bytes used to generate the state.
// 32 bytes = 256 bits of entropy, which is considered cryptographically secure.
// When base64url encoded without padding, this produces a 43-character string.
const StateLength = 32

// GenerateState creates a cryptographically secure state parameter for OIDC authentication.
//
// The state parameter serves two purposes:
//  1. CSRF protection: Links the browser authentication to this specific CLI session
//  2. Session correlation: Allows the CLI to poll for and retrieve its token
//
// The generated state has the following properties:
//   - Length: 43 characters (32 bytes base64url encoded)
//   - Entropy: 256 bits (cryptographically secure)
//   - Encoding: base64url (characters: A-Za-z0-9_-)
//   - No padding: Padding characters (=) are stripped for URL safety
//
// Example output: "dGhpcyBpcyBhIHRlc3Qgc3RhdGUgdmFsdWU"
//
// Returns an error if the system's cryptographic random number generator fails,
// which would indicate a serious system-level issue.
func GenerateState() (string, error) {
	// Allocate buffer for random bytes
	bytes := make([]byte, StateLength)

	// Read cryptographically secure random bytes from the system.
	// This uses /dev/urandom on Unix systems or CryptGenRandom on Windows.
	// An error here would indicate a serious system issue (e.g., entropy exhaustion).
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate random state: %w", err)
	}

	// Encode as base64url without padding.
	// base64url uses URL-safe characters: A-Z, a-z, 0-9, -, _
	// RawURLEncoding omits padding (=) which could cause issues in query parameters.
	//
	// 32 bytes -> 43 characters (32 * 8 / 6 = 42.67, rounded up)
	state := base64.RawURLEncoding.EncodeToString(bytes)

	return state, nil
}

// ValidateStateFormat checks if a state string has the expected format.
// This is a basic validation to catch obvious errors - the server performs
// the authoritative validation.
//
// A valid state must:
//   - Be exactly 43 characters (32 bytes base64url encoded)
//   - Contain only base64url characters (A-Za-z0-9_-)
//
// This function does NOT validate that the state is cryptographically random
// or that it was generated by this CLI - only the server can verify that.
func ValidateStateFormat(state string) bool {
	// Check length: 32 bytes base64url encoded = 43 characters
	if len(state) != 43 {
		return false
	}

	// Check that all characters are valid base64url characters
	for _, c := range state {
		if !isBase64URLChar(c) {
			return false
		}
	}

	return true
}

// isBase64URLChar returns true if the rune is a valid base64url character.
// Valid characters are: A-Z, a-z, 0-9, -, _
func isBase64URLChar(c rune) bool {
	return (c >= 'A' && c <= 'Z') ||
		(c >= 'a' && c <= 'z') ||
		(c >= '0' && c <= '9') ||
		c == '-' ||
		c == '_'
}
